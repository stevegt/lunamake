#!/usr/bin/python3

import argparse
import collections
import logging
import os
import pprint
import re
import shlex
import subprocess
import sys
import time

from lmutil import Env, sh, shlex_join

class Config(collections.OrderedDict):

    def __init__(self, files):
        for fn in files:
            fh = open(fn, 'r')
            self.parse(fh)

    def parse(self, fh):

        # temporarily load rhs of each stanza into a string
        pattern = None
        for line in fh.readlines():
            line = line.rstrip()

            # comment lines start with '#'
            if re.match('^\s*#', line):
                continue

            # stanzas start in column 0
            m = re.match('^(\S+):(.*)', line)
            if m:
                pattern = m.group(1)
                assert pattern not in self.keys()
                self[pattern] = m.group(2)
                continue

            # continuations are indented
            m = re.match('^\s+(.*?)$', line)
            if m:
                self[pattern] += " %s" % m.group(1)
                continue

        # replace temporary strings with parsed tuples
        for pattern, rhs in self.items():
            tuples = collections.OrderedDict()
            for token in shlex.split(rhs):
                m = re.match('^(\w+)=(.*)', token)
                if not m:
                    # token is a macro name -- use None to indicate that
                    var = token
                    val = None
                else:
                    var = m.group(1)
                    val = m.group(2)
                assert var not in tuples.keys(), (pattern, var, val, rhs)
                tuples[var] = val
            self[pattern] = tuples

        # expand macros by using ChainMap
        for pattern, tuples in self.items():
            maps = [tuples]
            for var, val in tuples.items():
                if val is None:
                    maps.append(self[var])
            self[pattern] = collections.ChainMap(*maps)


    def tuples(self, hostname):
        ''' build a customized tuple set for this host '''
        maps = []
        for pattern in reversed(self.keys()):
            if re.match(pattern, hostname):
                maps.append(self[pattern])
        # logging.debug(pprint.pformat(maps))
        tuples = dict(collections.ChainMap(*maps))
        # logging.debug(pprint.pformat(dict(tuples)))
        return tuples


def main():

    hostname = sh("hostname")

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-C", '--confdir', metavar="DIRECTORY", default='/var/lunamake',
            help="lunamake git repository")
    parser.add_argument("-H", '--hostname', metavar="HOSTNAME", default=hostname,
            help="local hostname")
    parser.add_argument("-l", '--log', metavar="LOG_LEVEL", default="INFO",
            help="log level name as defined in python logging module")
    parser.add_argument("-n", '--noop', action="store_true",
            help="do not modify any files outside of DIRECTORY")
    parser.add_argument('targets', metavar="TARGETS", nargs='*')
    args = parser.parse_args()

    env = Env(init=True)

    # set environment vars
    env.LM_DIR = os.path.dirname(os.path.abspath(sys.argv[0]))
    env.LM_HOSTNAME = args.hostname
    env.LM_LOGLEVEL = args.log.upper()
    env.LM_NOOP = args.noop and 'true' or 'false'
    env.LM_TARGETS = shlex.quote(shlex_join(args.targets))
    env.LM_MAKEFILE = os.path.join(env.LM_DIR, "Makefile")
    env.LM_LOCALDIR = os.path.join(env.LM_DIR, 'local')
    env.LM_REBOOT = os.path.join(env.LM_LOCALDIR, '.reboot')
    env.LM_ENV = os.path.join(env.LM_LOCALDIR, '.env')
    env.LM_STAMPDIR = os.path.join(env.LM_LOCALDIR, "stamps")
    # env.PATH = ':'.join((env.LM_DIR, os.environ['PATH']))

    if not os.path.exists(env.LM_LOCALDIR):
        os.mkdir(env.LM_LOCALDIR)

    if not os.path.exists(env.LM_STAMPDIR):
        os.mkdir(env.LM_STAMPDIR)

    # set up logging
    log_level = getattr(logging, env.LM_LOGLEVEL, None)
    logging.basicConfig(level=log_level)
        
    # change to config directory
    os.chdir(env.LM_DIR)

    # parse config files
    files = sorted(filter(lambda fn: fn.endswith(".conf"), os.listdir()))
    conf = Config(files)
    tuples = conf.tuples(env.LM_HOSTNAME)
    # pprint.pprint(tuples)
    for var, val in tuples.items():
        env.set(var, shlex.quote(val))
    env.save()

    # run all numbered scripts 
    scripts = sorted(filter(lambda fn: re.match('^\d+-', fn), os.listdir()))
    for script in scripts:
        # run script
        sh(os.path.join(env.LM_DIR, script))
        # update env
        env.load()

if __name__ == "__main__":
    main()
