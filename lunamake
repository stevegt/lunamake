#!/usr/bin/python3

import argparse
import collections
import logging
import os
import pprint
import re
import shlex
import subprocess
import sys
import time

class Env(dict):

    def __setattr__(self, var, val):
        self[var] = val
        self.__dict__[var] = val
        os.environ[var] = val

def main():

    # XXX move everything into numbered scripts, re-read a .env file after every script execution

    hostname = sh("hostname")

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-C", '--confdir', metavar="DIRECTORY", 
            help="directory containing lunamake configuration files (default current)")
    parser.add_argument("-H", '--hostname', metavar="HOSTNAME", default=hostname,
            help="name of local host; to be matched with patterns in config file(s)")
    parser.add_argument("-l", '--log', metavar="LOG_LEVEL", default="INFO",
            help="log level name as defined in python logging module")
    parser.add_argument("-n", '--noop', action="store_true",
            help="do not modify any files outside of DIRECTORY")
    parser.add_argument('targets', metavar="TARGETS", nargs='*')
    args = parser.parse_args()

    # set up logging
    log_level = getattr(logging, args.log.upper(), None)
    logging.basicConfig(level=log_level)
        
    # change to config directory
    if args.confdir:
        os.chdir(args.confdir)

    # set environment vars
    env = Env()
    env.LM_DIR = os.path.abspath('.')
    env.LM_STAMPDIR = os.path.join(env.LM_DIR, "stamps")
    env.LM_MAKEFILE = os.path.join(env.LM_DIR, "Makefile")
    env.LM_HOSTNAME = args.hostname
    env.LM_REBOOT_FN = os.path.join(env.LM_STAMPDIR, ".reboot")

    if not os.path.exists(env.LM_STAMPDIR):
        os.mkdir(env.LM_STAMPDIR)

    # call external prog and read stdout to set more env vars
    envstr = sh('./pre')
    for line in envstr.splitlines():
        var, val = line.split('=', maxsplit=1)
        os.environ[var] = val
        logging.info(line)

    # expand make targets from env vars of same name
    make_targets = expand_targets(args.targets)
    logging.info(make_targets)

    # run 'make'
    touchall(env.LM_STAMPDIR)
    makeflags = args.noop and ["-n"] or [""]
    makeflags.extend(shlex.split("-C %s -f %s" % (env.LM_STAMPDIR, env.LM_MAKEFILE)))
    make(makeflags, make_targets)

    # run stow and triggers
    sh('./post')

    # check reboot semaphore file
    if os.path.exists(env.LM_REBOOT_FN):
        os.unlink(env.LM_REBOOT_FN)
        make(["-B"], ['reboot'])

def make(flags, targets):
    cmd = ['make'] + flags + targets
    cmd = ' '.join(cmd)
    logging.info(cmd)
    subprocess.run(cmd, shell=True, check=True)

def sh(cmd):
    if type(cmd) == str:
        cmd = shlex.split(cmd)
    out = subprocess.check_output(cmd)
    out = out.decode().strip()
    return out

def touchall(dirname):
    '''
    prevent make from acting like make -- we don't want it to try to rebuild "old" targets
    '''
    now = time.time()
    for fn in filter(lambda fn: not fn.startswith("."), os.listdir(dirname)):
        touch(now, os.path.join(dirname, fn))

def touch(now, fn):
    os.utime(fn, times=(now, now))

def expand_targets(targets):
    '''
    Given a list of targets, expand any that are env variable names by
    replacing them with their env variable values.
    '''
    out = []
    for target in targets:
        val = os.environ.get(target)
        if val is None:
            # target is a make target; pass it through 
            out.append(target)
        else:
            # target is an env var name; replace with val
            out.extend(shlex.split(val))
    return out

if __name__ == "__main__":
    main()
