#!/usr/bin/python3

import collections
import os
import pprint
import re
import shlex

def main():

    # parse .conf file(s) 
    files = sorted(filter(lambda fn: fn.endswith(".conf"), os.listdir()))
    conf = Config(files)
    tuples = conf.tuples(os.environ["LM_HOSTNAME"])
    # pprint.pprint(tuples)
    for var, val in tuples.items():
        print("%s=%s" % (var, shlex.quote(val)))


class Config(collections.OrderedDict):

    def __init__(self, files):
        for fn in files:
            fh = open(fn, 'r')
            self.parse(fh)

    def parse(self, fh):

        # temporarily load rhs of each stanza into a string
        pattern = None
        for line in fh.readlines():
            line = line.rstrip()

            # comment lines start with '#'
            if re.match('^\s*#', line):
                continue

            # stanzas start in column 0
            m = re.match('^(\S+):(.*)', line)
            if m:
                pattern = m.group(1)
                assert pattern not in self.keys()
                self[pattern] = m.group(2)
                continue

            # continuations are indented
            m = re.match('^\s+(.*?)$', line)
            if m:
                self[pattern] += " %s" % m.group(1)
                continue

        # replace temporary strings with parsed tuples
        for pattern, rhs in self.items():
            tuples = collections.OrderedDict()
            for token in shlex.split(rhs):
                m = re.match('^(\w+)=(.*)', token)
                if not m:
                    # token is a macro name -- use None to indicate that
                    var = token
                    val = None
                else:
                    var = m.group(1)
                    val = m.group(2)
                assert var not in tuples.keys(), (pattern, var, val, rhs)
                tuples[var] = val
            self[pattern] = tuples

        # expand macros by using ChainMap
        for pattern, tuples in self.items():
            maps = [tuples]
            for var, val in tuples.items():
                if val is None:
                    maps.append(self[var])
            self[pattern] = collections.ChainMap(*maps)


    def tuples(self, hostname):
        ''' build a customized tuple set for this host '''
        maps = []
        for pattern in reversed(self.keys()):
            if re.match(pattern, hostname):
                maps.append(self[pattern])
        # logging.debug(pprint.pformat(maps))
        tuples = dict(collections.ChainMap(*maps))
        # logging.debug(pprint.pformat(dict(tuples)))
        return tuples


if __name__ == "__main__":
    main()
